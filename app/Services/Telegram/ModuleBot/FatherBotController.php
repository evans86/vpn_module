<?php

namespace App\Services\Telegram\ModuleBot;

use App\Dto\Salesman\SalesmanFactory;
use App\Models\KeyActivate\KeyActivate;
use App\Models\Pack\Pack;
use App\Models\PackSalesman\PackSalesman;
use App\Models\Salesman\Salesman;
use App\Services\Salesman\SalesmanService;
use App\Services\Telegram\TelegramKeyboard;
use Telegram\Bot\Keyboard\Button;
use Telegram\Bot\Keyboard\Keyboard;
use Illuminate\Support\Facades\Log;

class FatherBotController extends AbstractTelegramBot
{
    private const STATE_WAITING_TOKEN = 'waiting_token';
    private const STATE_WAITING_PAYMENT = 'waiting_payment';

    private ?string $userState = null;
    private ?int $pendingPackId = null;

    /**
     * Process incoming update and route to appropriate action
     */
    protected function processUpdate(): void
    {
        try {
            if ($this->update->getMessage()->text === '/start') {
                Log::debug('Send message: ' . $this->update->getMessage()->text);
                $this->userState = null;
                $this->start();
                return;
            }

            $message = $this->update->getMessage();
            $callbackQuery = $this->update->callbackQuery;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
            if ($this->userState === self::STATE_WAITING_TOKEN && $message) {
                $this->handleBotToken($message->text);
                return;
            }

            if ($this->userState === self::STATE_WAITING_PAYMENT && $callbackQuery) {
                $this->processCallback($callbackQuery->data);
                return;
            }

            if ($callbackQuery) {
                $this->processCallback($callbackQuery->data);
            }
        } catch (\Exception $e) {
            Log::error('Error processing update: ' . $e->getMessage());
            $this->sendErrorMessage();
        }
    }

    /**
     * Handle bot token from user
     * @param string $token
     */
    private function handleBotToken(string $token): void
    {
        try {
            $salesman = Salesman::where('telegram_id', $this->chatId)->firstOrFail();

            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º webhook –¥–ª—è –±–æ—Ç–∞ –ø—Ä–æ–¥–∞–≤—Ü–∞
            $webhookPath = 'salesman-bot/init';
            if (!$this->setWebhook($token, $webhookPath)) {
                $this->sendMessage('–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ –±–æ—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–æ–∫–µ–Ω –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
                return;
            }

            $salesmanDto = SalesmanFactory::fromEntity($salesman);
            $salesmanDto->token = $token;
            $salesmanDto->bot_link = $this->getBotLinkFromToken($token);

            $this->salesmanService->updateToken($salesmanDto);

            $this->userState = null;
            $this->sendMessage("–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω!\n–¢–æ–∫–µ–Ω: {$token}\n–°—Å—ã–ª–∫–∞ –Ω–∞ –±–æ—Ç–∞: {$salesmanDto->bot_link}");
            $this->generateMenu();
        } catch (\Exception $e) {
            Log::error('Bot token handling error: ' . $e->getMessage());
            $this->sendErrorMessage();
        }
    }

    /**
     * Validate bot token format
     * @param string $token
     * @return bool
     */
//    private function isValidBotToken(string $token): bool
//    {
//        // –ú–æ–∂–Ω–æ –¥–æ–ø–æ–ª–Ω–∏—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
//        return preg_match('/^\d+:[\w-]{35}$/', $token);
//    }

    /**
     * Get bot link from token
     * @param string $token
     * @return string
     */
    private function getBotLinkFromToken(string $token): string
    {
        // –ü–æ–ª—É—á–∞–µ–º –∏–º—è –±–æ—Ç–∞
        $botName = explode(':', $token)[0];
        return '@bot' . $botName;
    }

    /**
     * Start command handler
     */
    protected function start(): void
    {
        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            $existingSalesman = Salesman::where('telegram_id', $this->chatId)->first();
            Log::debug('existingSalesman: ' . $this->chatId);

            if (!$existingSalesman) {
                $this->salesmanService->create($this->chatId, $this->username);
            }

            $this->generateMenu();
        } catch (\Exception $e) {
            Log::error('Start command error: ' . $e->getMessage());
            $this->sendErrorMessage();
        }
    }

    /**
     * Generate menu
     */
    protected function generateMenu(): void
    {
        $keyboard = Keyboard::make()
            ->setResizeKeyboard(true)
            ->setOneTimeKeyboard(false)
            ->row(
                Keyboard::inlineButton([
                    'text' => 'üõç –ö—É–ø–∏—Ç—å –ø–∞–∫–µ—Ç',
                    'callback_data' => 'packs'
                ]),
                Keyboard::inlineButton([
                    'text' => 'ü§ñ –ú–æ–π –±–æ—Ç',
                    'callback_data' => 'bindBot'
                ])
            )
            ->row([
                Keyboard::inlineButton([
                    'text' => 'üë§ –ü—Ä–æ—Ñ–∏–ª—å',
                    'callback_data' => 'profile'
                ]),
                Keyboard::inlineButton([
                    'text' => '‚ùì –ü–æ–º–æ—â—å',
                    'callback_data' => 'help'
                ])
            ]);

        $message = "üëã *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–∏—Å—Ç–µ–º—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞–º–∏ VPN*\n\n";
        $message .= "üî∏ –ü–æ–∫—É–ø–∞–π—Ç–µ –ø–∞–∫–µ—Ç—ã –∫–ª—é—á–µ–π\n";
        $message .= "üî∏ –°–æ–∑–¥–∞–≤–∞–π—Ç–µ —Å–≤–æ–µ–≥–æ –±–æ—Ç–∞\n";
        $message .= "üî∏ –ü—Ä–æ–¥–∞–≤–∞–π—Ç–µ VPN –¥–æ—Å—Ç—É–ø—ã\n";

        Log::debug('Send message: ' . $message . json_encode($keyboard));

        $this->sendMessage($message, $keyboard);
    }

    /**
     * Process callback queries
     * @param string $data
     */
    private function processCallback(string $data): void
    {
        $params = [];
        if (str_contains($data, '?')) {
            [$action, $queryString] = explode('?', $data);
            parse_str($queryString, $params);
        } else {
            $action = $data;
        }

        $methodName = 'action' . ucfirst($action);
        if (method_exists($this, $methodName)) {
            $this->$methodName($params['id'] ?? null);
        }
    }

    /**
     * Packs action
     */
    private function actionPacks(): void
    {
        $packs = Pack::all();
        $keyboard = new TelegramKeyboard();

        foreach ($packs as $pack) {
            $keyboard->addButtons([[
                "text" => "üì¶ {$pack->period} - {$pack->price}‚ÇΩ",
                "callback_data" => "pack?id={$pack->id}"
            ]]);
        }

        $message = "üõç *–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–∞–∫–µ—Ç—ã –∫–ª—é—á–µ–π:*\n\n";
        $message .= "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç –¥–ª—è –ø–æ–∫—É–ø–∫–∏:";

        $this->sendMessage($message, ['parse_mode' => 'Markdown', 'reply_markup' => $keyboard->getInline()]);
    }

    /**
     * Pack action
     */
    private function actionPack(int $id): void
    {
        /**
         * @var Pack $pack
         */
        $pack = Pack::find($id);
        if (!$pack) {
            $this->sendMessage('‚ùå –ü–∞–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
            return;
        }

        $keyboard = new TelegramKeyboard();
        $keyboard->addButtons([[
            "text" => "üí≥ –ö—É–ø–∏—Ç—å –∑–∞ {$pack->price}‚ÇΩ",
            "callback_data" => "confirmPurchase?id={$pack->id}"
        ]]);

        $message = "üíé *–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –ø–∞–∫–µ—Ç–∞:*\n";
        $message .= "üîë –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—é—á–µ–π: {$pack->count}\n";
        $message .= "‚è± –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: {$pack->period} –¥–Ω–µ–π\n";
        $message .= "üìä –¢—Ä–∞—Ñ–∏–∫ –Ω–∞ –∫–ª—é—á: {$pack->traffic_limit} GB\n";
        $message .= "üíµ –°—Ç–æ–∏–º–æ—Å—Ç—å: {$pack->price}‚ÇΩ\n\n";

        $this->sendMessage($message, ['parse_mode' => 'Markdown', 'reply_markup' => $keyboard->getInline()]);
    }

    /**
     * Confirm purchase action
     */
    private function actionConfirmPurchase(int $id): void
    {
        $pack = Pack::find($id);
        if (!$pack) {
            $this->sendMessage('‚ùå –ü–∞–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
            return;
        }

        $this->pendingPackId = $id;
        $this->userState = self::STATE_WAITING_PAYMENT;

        $message = "üí≥ *–û–ø–ª–∞—Ç–∞ –ø–∞–∫–µ—Ç–∞ {$pack->name}*\n\n";
        $message .= "–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ: {$pack->price}‚ÇΩ\n\n";
        $message .= "–î–ª—è –æ–ø–ª–∞—Ç—ã –ø–µ—Ä–µ–≤–µ–¥–∏—Ç–µ —É–∫–∞–∑–∞–Ω–Ω—É—é —Å—É–º–º—É –ø–æ —Ä–µ–∫–≤–∏–∑–∏—Ç–∞–º:\n";
//        $message .= "üí† –°–±–µ—Ä–±–∞–Ω–∫: `1234 5678 9012 3456`\n";
//        $message .= "üí† –¢–∏–Ω—å–∫–æ—Ñ—Ñ: `9876 5432 1098 7654`\n\n";
//        $message .= "‚ùóÔ∏è –í –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ —É–∫–∞–∂–∏—Ç–µ: `VPN_{$this->chatId}`\n\n";
        $message .= "–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É '–Ø –æ–ø–ª–∞—Ç–∏–ª'";

        $keyboard = new TelegramKeyboard();
        $keyboard->addButtons([[
            "text" => "‚úÖ –Ø –æ–ø–ª–∞—Ç–∏–ª",
            "callback_data" => "checkPayment?id={$id}"
        ]]);

        $this->sendMessage($message, ['parse_mode' => 'Markdown', 'reply_markup' => $keyboard->getInline()]);
    }

    /**
     * Check payment action
     */
    private function actionCheckPayment(int $id): void
    {
        if ($this->userState !== self::STATE_WAITING_PAYMENT || $this->pendingPackId !== $id) {
            $this->sendMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–ø–ª–∞—Ç—ã. –ù–∞—á–Ω–∏—Ç–µ –ø–æ–∫—É–ø–∫—É –∑–∞–Ω–æ–≤–æ.');
            return;
        }

        try {
            /**
             * @var Pack $pack
             */
            $pack = Pack::find($id);
            if (!$pack) {
                $this->sendMessage('‚ùå –ü–∞–∫–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }

            /**
             * @var Salesman $salesman
             */
            $salesman = Salesman::where('telegram_id', $this->chatId)->firstOrFail();

            // TODO: –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–ø–ª–∞—Ç—ã —á–µ—Ä–µ–∑ –ø–ª–∞—Ç–µ–∂–Ω—É—é —Å–∏—Å—Ç–µ–º—É

            // –°–æ–∑–¥–∞–µ–º –ø–∞–∫–µ—Ç –ø—Ä–æ–¥–∞–≤—Ü–∞
            $packSalesman = $this->packSalesmanService->create($pack->id, $salesman->id);
            // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å–∏ –∫–ª—é—á–µ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
            $this->packSalesmanService->success($packSalesman->id);

            // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–ª—é—á–∏ –ø–∞–∫–µ—Ç–∞
            $keys = KeyActivate::where('pack_salesman_id', $packSalesman->id)
                ->where('status', KeyActivate::PAID)
                ->get();

            $this->userState = null;
            $this->pendingPackId = null;

            $message = "‚úÖ *–ü–∞–∫–µ—Ç —É—Å–ø–µ—à–Ω–æ –∫—É–ø–ª–µ–Ω!*\n\n";
            $message .= "üîë –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª—é—á–µ–π: {$pack->count}\n";
            $message .= "‚è± –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: {$pack->period} –¥–Ω–µ–π\n";
            $message .= "üìä –¢—Ä–∞—Ñ–∏–∫ –Ω–∞ –∫–ª—é—á–∏: {$pack->traffic_limit} GB\n\n";

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –∫–ª—é—á–µ–π
            $message .= "*–í–∞—à–∏ VPN –∫–ª—é—á–∏ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏:*\n\n";
            foreach ($keys as $key) {
                $message .= "üîë `{$key->id}`\n";
            }
            $message .= "\n‚ÑπÔ∏è –≠—Ç–∏ –∫–ª—é—á–∏ –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–∞–≤–∞—Ç—å —á–µ—Ä–µ–∑ —Å–≤–æ–µ–≥–æ –±–æ—Ç–∞.\n";
            $message .= "–ö–ª–∏–µ–Ω—Ç—ã —Å–º–æ–≥—É—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –∏—Ö —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /activate\n\n";

            if (!$salesman->token) {
                $message .= "‚ùóÔ∏è *–í–∞–∂–Ω–æ:* –ü—Ä–∏–≤—è–∂–∏—Ç–µ —Å–≤–æ–µ–≥–æ –±–æ—Ç–∞ –¥–ª—è –Ω–∞—á–∞–ª–∞ –ø—Ä–æ–¥–∞–∂\n";
                $message .= "–ù–∞–∂–º–∏—Ç–µ 'ü§ñ –ú–æ–π –±–æ—Ç' –≤ –º–µ–Ω—é";
            } else {
                $message .= "ü§ñ –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —Å–≤–æ–µ–≥–æ –±–æ—Ç–∞ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏ –∫–ª—é—á–µ–π:\n";
                $message .= $salesman->bot_link;
            }

            $this->sendMessage($message, ['parse_mode' => 'Markdown']);
        } catch (\Exception $e) {
            Log::error('Pack purchase error: ' . $e->getMessage());
            $this->sendErrorMessage();
        }
    }

    /**
     * Profile action
     */
    private function actionProfile(): void
    {
        try {
            /**
             * @var Salesman $salesman
             */
            $salesman = Salesman::where('telegram_id', $this->chatId)->firstOrFail();

            $activePacks = PackSalesman::where('salesman_id', $salesman->id)
                ->where('status', PackSalesman::PAID)
                ->count();

            $totalKeys = KeyActivate::whereHas('packSalesman', function ($query) use ($salesman) {
                $query->where('salesman_id', $salesman->id);
            })->count();

            $soldKeys = KeyActivate::whereHas('packSalesman', function ($query) use ($salesman) {
                $query->where('salesman_id', $salesman->id);
            })
                ->whereNotNull('user_tg_id')
                ->count();

            $message = "üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å:*\n\n";
            $message .= "üÜî ID: `{$salesman->id}`\n";
            $message .= "üë§ Username: @{$salesman->username}\n";
            $message .= "üìÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: {$salesman->created_at->format('d.m.Y')}\n\n";

            if ($salesman->token) {
                $message .= "ü§ñ *–í–∞—à –±–æ—Ç:*\n";
                $message .= "üîó –°—Å—ã–ª–∫–∞: {$salesman->bot_link}\n\n";
            }

            $message .= "üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\n";
            $message .= "üì¶ –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–∞–∫–µ—Ç–æ–≤: {$activePacks}\n";
            $message .= "üîë –í—Å–µ–≥–æ –∫–ª—é—á–µ–π: {$totalKeys}\n";
            $message .= "‚úÖ –ü—Ä–æ–¥–∞–Ω–æ –∫–ª—é—á–µ–π: {$soldKeys}\n";

            $this->sendMessage($message, ['parse_mode' => 'Markdown']);
        } catch (\Exception $e) {
            Log::error('Profile error: ' . $e->getMessage());
            $this->sendErrorMessage();
        }
    }

    /**
     * Help action
     */
    private function actionHelp(): void
    {
        $message = "‚ùì *–ü–æ–º–æ—â—å –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞*\n\n";
        $message .= "*–ö–∞–∫ –Ω–∞—á–∞—Ç—å –ø—Ä–æ–¥–∞–≤–∞—Ç—å VPN:*\n\n";
        $message .= "1Ô∏è‚É£ –ö—É–ø–∏—Ç–µ –ø–∞–∫–µ—Ç –∫–ª—é—á–µ–π\n";
        $message .= "2Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ –±–æ—Ç–∞ –≤ @BotFather\n";
        $message .= "3Ô∏è‚É£ –ü—Ä–∏–≤—è–∂–∏—Ç–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω\n";
        $message .= "4Ô∏è‚É£ –ù–∞—á–Ω–∏—Ç–µ –ø—Ä–æ–¥–∞–≤–∞—Ç—å –¥–æ—Å—Ç—É–ø—ã\n\n";
        $message .= "*–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ:*\n";
        $message .= "üì¶ –ü–∞–∫–µ—Ç—ã –º–æ–∂–Ω–æ –¥–æ–∫—É–ø–∞—Ç—å\n";
        $message .= "üîÑ –ö–ª—é—á–∏ –∞–∫—Ç–∏–≤–∏—Ä—É—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n";
        $message .= "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –ø—Ä–æ—Ñ–∏–ª–µ\n\n";
        $message .= "–û—Å—Ç–∞–ª–∏—Å—å –≤–æ–ø—Ä–æ—Å—ã? –ü–∏—à–∏—Ç–µ @support";

        $this->sendMessage($message, ['parse_mode' => 'Markdown']);
    }

    /**
     * Bind bot action handler
     */
    private function actionBindBot(): void
    {
        try {
            /**
             * @var Salesman $salesman
             */
            $salesman = Salesman::where('telegram_id', $this->chatId)->firstOrFail();

            if ($salesman->token) {
                $text = "–£ –≤–∞—Å —É–∂–µ –ø—Ä–∏–≤—è–∑–∞–Ω –±–æ—Ç:\n–¢–æ–∫–µ–Ω: {$salesman->token}\n–°—Å—ã–ª–∫–∞: {$salesman->bot_link}\n\n";
                $text .= "–•–æ—Ç–∏—Ç–µ –ø—Ä–∏–≤—è–∑–∞—Ç—å –¥—Ä—É–≥–æ–≥–æ –±–æ—Ç–∞? –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω.";
            } else {
                $text = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞.\n\n";
                $text .= "–¢–æ–∫–µ–Ω –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —É @BotFather –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –±–æ—Ç–∞.";
            }

            $this->userState = self::STATE_WAITING_TOKEN;
            $this->sendMessage($text);
        } catch (\Exception $e) {
            Log::error('Bot binding error: ' . $e->getMessage());
            $this->sendErrorMessage();
        }
    }
}
